#This is a function designed to facilitate the use of viper.
#Copyright (C) 2018  Aurelien Dugourd

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

library(viper)

#'\code{df_to_viper_regulon}
#'
#'This function is designed to generate a ready to use regulon object for viper
#'from a 3 column dataframe representation of a target set collection.
#'
#'@param df a dataframe of n*3 dimension. The first column corresponds the targets,
#'and the second column indicates which regulon does each target belongs to.
#'The third column corresponds to the weight and sign of the interaction between
#'a regulon and its targets.
#'
#'@return a list where each element is a regulon in the viper format. This list
#'is ready to be used as a regulon set in viper.
df_to_viper_regulon <- function(df)
{
  names(df) <- c("feature","pathway","sign")
  df <- df[complete.cases(df),]

  pathway_regulon <- list(0)
  i <- 1
  for(pathway in unique(df$pathway))
  {
    pathway_feature_list <- list(0)
    features <- df[df$pathway == pathway, 3]
    names(features) <- df[df$pathway == pathway, 1]
    pathway_feature_list[[1]] <- features
    pathway_feature_list[[2]] <- rep(1,length(features))
    names(pathway_feature_list) <- c("tfmode","likelihood")

    pathway_regulon[[i]] <- pathway_feature_list
    i <- i+1
  }
  names(pathway_regulon) <- unique(df$pathway)
  return(pathway_regulon)
}

#'\code{runViper}
#'
#'This function is designed to facilitate the use of viper downstream of a limma
#'differential analysis.
#'
#'@param ttop_list a list where each element is a table corresponding to the
#'result of a differential analysis with one contrast in limma, a formatted by
#'the ttopFormatter function. Columns : ID,logFC,AveExpr,t,P.Value,adj.P.Val,B.
#'All columns need to be present, but only ID and t actually need to have values.
#'@param regulon a standard viper regulon object. A list as returned by the
#'df_to_viper_regulon function.
#'@param nperm the number of permutations to generate the null model. If set to
#'0, the parametric distribution of aREA will be used.
#'@param core the number of core to be used.
#'@param minsize the minimum number of targets a regulon needs to have to be
#'used in the analisys.
#'
#'@return a list where each element is the result of viper function with one contrast.
runViper <- function(ttop_list, regulon, nperm = 0, core = 1, minsize = 2)
{
  viperResList <- list(0)

  j <- 1
  for(ttop in ttop_list)
  {
    ttop <- ttop[complete.cases(ttop),]

    ges <- ttop$t
    names(ges) <- ttop[,1]

    if(nperm >0)
    {
      nullDF_genessampling <- list(0)
      for (i in 1:nperm)
      {
        nullDF_genessampling[[i]] <- sample(ges, size = length(ges), replace = F)
      }

      nullDF_genessampling <- data.frame(nullDF_genessampling)
      names(nullDF_genessampling) <- c(1:nperm)
      row.names(nullDF_genessampling) <- names(ges)
      nullDF_genessampling <- as.matrix(nullDF_genessampling)

      viperRes <- msviper(ges = ges, regulon = regulon, nullmodel = nullDF_genessampling, verbose = F, core = core, minsize = minsize, ges.filter = FALSE)

      viperResList[[j]] <- viperRes

      j <- j+1
    }
    else
    {
      viperRes <- viper(eset = ges, regulon = regulon, verbose = F, core = core, minsize = minsize, eset.filter = FALSE)

      viperResList[[j]] <- viperRes

      j <- j+1
    }
  }
  names(viperResList) <- names(ttop_list)
  return(viperResList)
}

#'\code{makeViperResDf}
#'
#'This function is designed generate a dataframe summarising the result of the
#'runViper function. Each column of the dataframe correspond to a contrast.
#'
#'@param viperResList a list of viper results, such as generated by the runViper
#'function
#'
#'@return a dataframe of n*m+1 dimension, where each row represent a tested regulon.
#'The first column is the name of regulon, and the other columns are the contrasts.
makeViperResDf <- function(viperResList)
{
  i <- 1
  for (viperRes in viperResList)
  {
    viperScores <- viperRes

    viperScores <- data.frame(viperScores)

    viperScores$ID <- row.names(viperScores)

    names(viperScores)[1] <- i

    if (i == 1)
    {
      viperResDf <- viperScores
    }
    else
    {
      viperResDf <- merge(viperResDf, viperScores, by = "ID", all = T)
    }

    i <- i+1
  }
  if(i > 2)
  {
    names(viperResDf)[2:length(viperResDf[1,])] <- names(viperResList)
  }
  else
  {
    viperResDf <- viperResDf[,c(2,1)]
    names(viperResDf) <- c("ID", names(viperResList))
  }

  return(viperResDf)
}
